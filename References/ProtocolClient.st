'From Squeak5.2 of 13 December 2018 [latest update: #18225] on 28 May 2021 at 6:31:48 pm'!Object subclass: #ProtocolClient	instanceVariableNames: 'stream connectInfo serverCapabilities lastResponse pendingResponses progressObservers'	classVariableNames: ''	poolDictionaries: ''	category: 'Network-Protocols'!!ProtocolClient commentStamp: 'gk 12/13/2005 00:34' prior: 0!ProtocolClient is the abstract super class for a variety of network protocol clients.It uses a stream rather than the direct network access so it could also work for streams on serial connections etc.Structure:	stream				stream representing the connection to and from the server	connectInfo			information required for opening a connection	lastResponse			remembers the last response from the server.	progressObservers 	any object understanding #show: can be registered as a progress observer (login, transfer, etc)!!ProtocolClient methodsFor: 'accessing' stamp: 'mir 3/7/2002 14:55'!logProgressToTranscript	self progressObservers add: Transcript! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 5/9/2003 15:52'!messageText	^super messageText		ifNil: [self response]! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 5/9/2003 15:52'!response	^self protocolInstance lastResponse! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!stream	^stream! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!stream: aStream	stream := aStream! !!ProtocolClient methodsFor: 'actions' stamp: 'mir 3/7/2002 13:10'!close	self stream		ifNotNil: [			self stream close.			stream := nil]! !!ProtocolClient methodsFor: 'actions' stamp: 'mir 3/7/2002 13:11'!reopen	self ensureConnection! !!ProtocolClient methodsFor: 'testing' stamp: 'mir 3/7/2002 14:33'!isConnected	^stream notNil		and: [stream isConnected]! !!ProtocolClient methodsFor: 'testing' stamp: 'pre 5/8/2017 14:45'!serverSupportsStarttls	^ self serverCapabilities at: self starttlsVerb ifAbsent: [false]! !!ProtocolClient methodsFor: 'testing' stamp: 'pre 5/11/2017 16:49'!tlsIsActive	^ self connectionInfo at: #tlsActive ifAbsent: [false]! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!connectionInfo	connectInfo ifNil: [connectInfo := Dictionary new].	^connectInfo! !!ProtocolClient methodsFor: 'private' stamp: 'mir 2/25/2002 19:34'!defaultPortNumber	^self class defaultPortNumber! !!ProtocolClient methodsFor: 'private' stamp: 'mir 11/14/2002 18:29'!ensureConnection	self isConnected		ifTrue: [^self].	self stream		ifNotNil: [self stream close].	self stream: (SocketStream openConnectionToHost: self host port: self port).	self checkResponse.	self login! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:56'!host	^self connectionInfo at: #host! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:37'!host: hostId	^self connectionInfo at: #host put: hostId! !!ProtocolClient methodsFor: 'private' stamp: 'pre 5/4/2017 17:44'!hostName	^ self connectionInfo at: #hostName ifAbsent: [NetNameResolver nameForAddress: self host]! !!ProtocolClient methodsFor: 'private' stamp: 'pre 5/4/2017 17:44'!hostName: aString	^ self connectionInfo at: #hostName put: aString! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 13:35'!lastResponse	^lastResponse! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 13:35'!lastResponse: aString	lastResponse := aString.! !!ProtocolClient methodsFor: 'private' stamp: 'mir 2/25/2002 19:07'!logFlag	^self class logFlag! !!ProtocolClient methodsFor: 'private' stamp: 'mir 5/12/2003 18:10'!logProgress: aString	self progressObservers do: [:each | each show: aString].! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:40'!openOnHost: hostIP port: portNumber	self host: hostIP.	self port: portNumber.	self ensureConnection! !!ProtocolClient methodsFor: 'private' stamp: 'pre 5/8/2017 14:48'!parseCapabilities: lines	self serverCapabilities addAll: (lines select: [:l | l notEmpty] 			thenCollect: [:l | | tokens capability values |				tokens := l findTokens: String space.				capability := tokens first asSymbol.				values := tokens allButFirst					ifEmpty: [true]					ifNotEmpty: [:rawValues | rawValues collect: [:v | 						v isAllDigits							ifTrue: [v asNumber]							ifFalse: [v asSymbol]]].				capability -> values])! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:56'!password	^self connectionInfo at: #password! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:37'!password: aString	^self connectionInfo at: #password put: aString! !!ProtocolClient methodsFor: 'private' stamp: 'mir 7/23/2003 16:45'!pendingResponses	pendingResponses ifNil: [pendingResponses := OrderedCollection new].	^pendingResponses! !!ProtocolClient methodsFor: 'private' stamp: 'mir 7/23/2003 16:55'!popResponse	| pendingResponse |	pendingResponse := self pendingResponses removeFirst.	pendingResponses isEmpty		ifTrue: [pendingResponses := nil].	^pendingResponse! !!ProtocolClient methodsFor: 'private' stamp: 'mir 4/7/2003 16:57'!port	^self connectionInfo at: #port! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:38'!port: aPortNumber	^self connectionInfo at: #port put: aPortNumber! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 14:54'!progressObservers	progressObservers ifNil: [progressObservers := OrderedCollection new].	^progressObservers! !!ProtocolClient methodsFor: 'private' stamp: 'mir 7/23/2003 16:45'!pushResponse: aResponse	self pendingResponses add: aResponse! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!resetConnectionInfo	connectInfo := nil! !!ProtocolClient methodsFor: 'private' stamp: 'pre 5/8/2017 14:06'!serverCapabilities	serverCapabilities ifNil: [serverCapabilities := Dictionary new].	^serverCapabilities! !!ProtocolClient methodsFor: 'private' stamp: 'kph 9/23/2008 00:33'!standardTimeout	^ Socket standardTimeout! !!ProtocolClient methodsFor: 'private' stamp: 'pre 5/8/2017 14:45'!starttlsVerb	^ #STARTTLS! !!ProtocolClient methodsFor: 'private' stamp: 'mir 11/11/2002 16:19'!user	^self connectionInfo at: #user ifAbsent: [nil]! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:39'!user: aString	^self connectionInfo at: #user put: aString! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 7/23/2003 16:52'!checkForPendingError	"If data is waiting, check it to catch any error reports.	In case the response is not an error, push it back."	self stream isDataAvailable		ifFalse: [^self].	self fetchNextResponse.	self		checkResponse: self lastResponse		onError: [:response | (TelnetProtocolError protocolInstance: self) signal]		onWarning: [:response | (TelnetProtocolError protocolInstance: self) signal].	"if we get here, it wasn't an error"	self pushResponse: self lastResponse! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 5/9/2003 18:47'!checkResponse	"Get the response from the server and check for errors."	self		checkResponseOnError: [:response | (TelnetProtocolError protocolInstance: self) signal]		onWarning: [:response | (TelnetProtocolError protocolInstance: self) signal].! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 7/23/2003 16:51'!checkResponse: aResponse onError: errorBlock onWarning: warningBlock	"Get the response from the server and check for errors. Invoke one of the blocks if an error or warning is encountered. See class comment for classification of error codes."	self responseIsError		ifTrue: [errorBlock value: aResponse].	self responseIsWarning		ifTrue: [warningBlock value: aResponse].! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 7/23/2003 16:54'!checkResponseOnError: errorBlock onWarning: warningBlock	"Get the response from the server and check for errors. Invoke one of the blocks if an error or warning is encountered. See class comment for classification of error codes."	self fetchPendingResponse.	self checkResponse: self lastResponse onError: errorBlock onWarning: warningBlock! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 3/7/2002 13:16'!fetchNextResponse	self lastResponse: self stream nextLine! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 7/23/2003 16:50'!fetchPendingResponse	^pendingResponses		ifNil: [self fetchNextResponse; lastResponse]		ifNotNil: [self popResponse]! !!ProtocolClient methodsFor: 'private protocol' stamp: 'pre 5/8/2017 14:50'!responseIsSuccess	^ self responseCode = 220! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 5/12/2003 18:10'!sendCommand: aString	self stream sendCommand: aString.! !!ProtocolClient methodsFor: 'private protocol' stamp: 'mir 3/5/2002 14:31'!sendStreamContents: aStream	self stream sendStreamContents: aStream! !!ProtocolClient methodsFor: 'private protocol' stamp: 'pre 5/11/2017 16:49'!starttls	Smalltalk at: #SqueakSSL ifAbsent:[self error: 'SqueakSSL is missing'].		self sendCommand: self starttlsVerb.	self checkResponse.	self responseIsSuccess ifTrue: [		stream := SqueakSSL secureSocketStream on: stream socket.		stream sslConnectTo: self hostName.		self connectionInfo at: #tlsActive put: true].! !!ProtocolClient methodsFor: 'private testing' stamp: 'mir 3/7/2002 13:42'!responseIsError	self subclassResponsibility! !!ProtocolClient methodsFor: 'private testing' stamp: 'mir 3/7/2002 13:42'!responseIsWarning	self subclassResponsibility! !!ProtocolClient methodsFor: 'private testing' stamp: 'pre 5/8/2017 15:03'!wantsStarttls	^ self serverSupportsStarttls! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ProtocolClient class	instanceVariableNames: ''!!ProtocolClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 16:00'!defaultPortNumber	self subclassResponsibility! !!ProtocolClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 19:07'!logFlag	self subclassResponsibility! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'mir 2/25/2002 15:59'!openOnHost: hostIP port: portNumber	^self new openOnHost: hostIP port: portNumber! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'gk 3/2/2004 11:10'!openOnHostNamed: hostName	"If the hostname uses the colon syntax to express a certain portnumber	we use that instead of the default port number."	| i |	i := hostName indexOf: $:.	i = 0 ifTrue: [			^self openOnHostNamed: hostName port: self defaultPortNumber]		ifFalse: [			| s p | 			s := hostName truncateTo: i - 1.			p := (hostName copyFrom: i + 1 to: hostName size) asInteger.			^self openOnHostNamed: s port: p]	! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'pre 5/4/2017 17:45'!openOnHostNamed: hostName port: portNumber	| serverIP |	serverIP := NetNameResolver addressForName: hostName timeout: 20.	^ (self openOnHost: serverIP port: portNumber)		hostName: hostName;		yourself! !!ProtocolClient class methodsFor: 'retrieval' stamp: 'mir 3/5/2002 16:21'!retrieveMIMEDocument: aURI	self subclassResponsibility! !