'From Squeak5.2 of 13 December 2018 [latest update: #18225] on 28 May 2021 at 4:48:10 pm'!TelnetProtocolClient subclass: #SMTPClient	instanceVariableNames: ''	classVariableNames: 'UseTLSIfAvailable'	poolDictionaries: ''	category: 'Network-Protocols'!!SMTPClient commentStamp: 'mir 2/21/2002 16:57' prior: 0!This class implements the SMTP (mail sending) protocol specified in RFC 821.HELO <SP> <domain> <CRLF>MAIL <SP> FROM:<reverse-path> <CRLF>RCPT <SP> TO:<forward-path> <CRLF>DATA <CRLF>RSET <CRLF>SEND <SP> FROM:<reverse-path> <CRLF>SOML <SP> FROM:<reverse-path> <CRLF>SAML <SP> FROM:<reverse-path> <CRLF>VRFY <SP> <string> <CRLF>EXPN <SP> <string> <CRLF>HELP [<SP> <string>] <CRLF>NOOP <CRLF>QUIT <CRLF>TURN <CRLF>!!SMTPClient methodsFor: 'public protocol' stamp: 'ar 12/4/2009 10:06'!localHostName	"The local host name for purposes of identifying the the server.	If nil, NetNameResolver localHostName will be used."	^self connectionInfo at: #localHostName ifAbsent: [NetNameResolver localHostName]! !!SMTPClient methodsFor: 'public protocol' stamp: 'ar 12/4/2009 10:06'!localHostName: aString	"The local host name for purposes of identifying the the server.	If nil, NetNameResolver localHostName will be used."	^self connectionInfo at: #localHostName put: aString! !!SMTPClient methodsFor: 'public protocol' stamp: 'mir 2/21/2002 15:43'!mailFrom: sender to: recipientList text: messageText	"deliver this mail to a list of users.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	self mailFrom: sender.	recipientList do: [ :recipient |		self recipient: recipient ].	self data: messageText.! !!SMTPClient methodsFor: 'public protocol' stamp: 'gk 8/4/2006 15:14'!useHelo	"If client use HELO instead of EHLO. HELO is the old protocol and	an old server may require it instead of EHLO."	^self connectionInfo at: #useHelo ifAbsent: [false]! !!SMTPClient methodsFor: 'public protocol' stamp: 'gk 8/4/2006 15:14'!useHelo: aBoolean	"Tell client to use HELO instead of EHLO. HELO is the old protocol and	an old server may require it instead of EHLO."	^self connectionInfo at: #useHelo put: aBoolean! !!SMTPClient methodsFor: 'utility' stamp: 'ar 12/4/2009 10:08'!encodeString: aString 	| str dec out |	str := String new: (aString size * 4 / 3 + 3) ceiling.	dec := Base64MimeConverter new.	dec		mimeStream: (out := WriteStream on: str);		dataStream: (ReadStream on: aString);		multiLine: false;		mimeEncode.	^out contents! !!SMTPClient methodsFor: 'private protocol' stamp: 'pre 5/4/2017 15:35'!data: messageData	"send the data of a message"	"DATA <CRLF>"	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine | | cookedLine |		cookedLine := messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine := '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'klub 1/3/2018 20:36'!initiateSession	"EHLO <SP> <domain> <CRLF>"	self sendCommand: (self useHelo ifTrue:['HELO '] ifFalse: ['EHLO ']) , self localHostName.	self checkResponse.		self parseCapabilities: (self lastResponse lines allButFirst 			collect: [:l | self valueOfResponseLine: l]).	(self tlsIsActive not and: [self serverSupportsStarttls] and: [self wantsStarttls])		ifTrue: [			self starttls.			self responseIsSuccess ifTrue: [				self initiateSession ] ]! !!SMTPClient methodsFor: 'private protocol' stamp: 'ar 2/10/2010 15:32'!login	"Send HELO first"	self initiateSession.	self user ifNil: [^self].	self sendCommand: 'AUTH LOGIN ' , (self encodeString: self user).	[self checkResponse]		on: TelnetProtocolError		do: [ :ex | ex isCommandUnrecognized ifTrue: [^ self] ifFalse: [ex pass]].	self sendCommand: (self encodeString: self password).	self checkResponse! !!SMTPClient methodsFor: 'private protocol' stamp: 'fbs 3/23/2004 17:16'!mailFrom: fromAddress	" MAIL <SP> FROM:<reverse-path> <CRLF>"	| address |	address := (MailAddressParser addressesIn: fromAddress) first.	self sendCommand: 'MAIL FROM: <', address, '>'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/21/2002 17:52'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	"QUIT <CRLF>"	self sendCommand: 'QUIT'.	self checkResponse.! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/21/2002 17:52'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	"RCPT <SP> TO:<forward-path> <CRLF>"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkResponse.! !!SMTPClient methodsFor: '*Network-MailSending' stamp: 'pre 11/22/2017 14:44'!sendMailMessage: mailMessage fromAddress: sender	"Convenience mechanism to handle handling of receivers	between MailMessage objects and SMTP."		| mailMessageToSend recipients |	mailMessageToSend := mailMessage deepCopy.	recipients := (mailMessage to findTokens: ',') , 					(mailMessage cc findTokens: ',') , 					(mailMessage bcc findTokens: ',').	recipients := recipients asSet collect: [:r | r withBlanksTrimmed].	mailMessageToSend bcc: ''.		self 		mailFrom: mailMessageToSend from 		to: recipients 		text: mailMessageToSend asSendableText! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SMTPClient class	instanceVariableNames: ''!!SMTPClient class methodsFor: 'accessing' stamp: 'mir 2/21/2002 17:22'!defaultPortNumber	^25! !!SMTPClient class methodsFor: 'accessing' stamp: 'mir 2/25/2002 19:07'!logFlag	^#smtp! !!SMTPClient class methodsFor: 'example' stamp: 'mir 2/22/2002 16:41'!example	"SMTPClient example"	self deliverMailFrom: 'm.rueger@acm.org' to: #('m.rueger@acm.org') text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'smtp.concentric.net'! !!SMTPClient class methodsFor: 'example' stamp: 'mir 2/22/2002 16:43'!example2	"SMTPClient example2"	self deliverMailFrom: 'm.rueger@acm.org' to: #('m.rueger@acm.org') text:'Subject: this is a testHello from Squeak!!'	usingServer: 'smtp.concentric.net'! !!SMTPClient class methodsFor: 'sending mail' stamp: 'mir 2/22/2002 12:30'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"Deliver a single email to a list of users and then close the connection.  For delivering multiple messages, it is best to create a single connection and send all mail over it.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	| smtpClient |	smtpClient := self openOnHostNamed: serverName.	[smtpClient mailFrom: fromAddress to: recipientList text: messageText.	smtpClient quit]		ensure: [smtpClient close]! !!SMTPClient class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 17:37'!openOnHost: hostIP port: portNumber	| client |	client := super openOnHost: hostIP port: portNumber.	client initiateSession.	^client! !