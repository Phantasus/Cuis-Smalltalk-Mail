Object subclass: #ICAccountInfo	instanceVariableNames: 'accountName host port username password ssl'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICAccountInfo commentStamp: 'LW 8/1/2020 11:20' prior: 0!An ICAccountInfo is a dataobject holding information needed to connect to a server such as server address and user credentials. It also ensures basic IMAP datatype validity.Instance Variables	accountName: Name of the account set by the user.	host: Hostname of the IMAP server.	port: Port of the IMAP service on the server. Default: 993.	username: Username to login at the IMAP server.	password: Password of the user to login at the server. Will be deleted after login.		!!ICAccountInfo methodsFor: 'comparing' stamp: 'NH 7/15/2020 10:31'!= anotherAccountInfo	^ (self class = anotherAccountInfo class)		and: [self asDictionary = anotherAccountInfo asDictionary]! !!ICAccountInfo methodsFor: 'comparing' stamp: 'LW 8/1/2020 12:04'!hash	"Answer an integer value that is related to the identity of the receiver."	^ self username bitXor: (self accountName bitXor: (self host bitXor: self port hash))! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 20:20'!accountName	^ accountName ifNil: [accountName := self class initialAccountName]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:35'!accountName: aString	accountName := aString! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 20:06'!host	^ host ifNil: [host := self class invalidHost]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:11'!host: aString	host := aString! !!ICAccountInfo methodsFor: 'accessing' stamp: 'JJ 6/12/2020 11:43'!missingFields		^ (self asDictionary select: [ :value | (value asString isEmpty) | (value = nil asString) ]) keys! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/15/2019 12:11'!password		^ password ifNil: [password := self class invalidPassword]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:18'!password: aString		(self canConvert: aString) ifFalse: [self error: (aString, ' is not IMAP convertable')].	password := aString! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 20:09'!port	^ port ifNil: [port := self class invalidPort]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:11'!port: aNumber	port := aNumber! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 20:21'!ssl	^ ssl ifNil: [ssl := self class initialSsl]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:34'!ssl: aBool	ssl := aBool! !!ICAccountInfo methodsFor: 'accessing' stamp: 'fr 7/26/2019 15:37'!username	^ username ifNil: [username := self class invalidUsername]! !!ICAccountInfo methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:18'!username: aString	(self canConvert: aString) ifFalse: [self error: (aString, ' is not IMAP convertable')].	username := aString! !!ICAccountInfo methodsFor: 'validating' stamp: 'NH 7/15/2020 09:58'!accountNameUnused	^ ICEndPoint connectionConfigurations			noneSatisfy: [:each | (self accountName) = (each accountName)]! !!ICAccountInfo methodsFor: 'validating' stamp: 'fr 7/26/2019 15:37'!canConvert: aString		^ ('"|\\' asRegex matchesIn: aString) isEmpty! !!ICAccountInfo methodsFor: 'validating' stamp: 'tg 7/15/2019 12:08'!hasValidServerInfo	^ self host ~= self class invalidHost		and: [self port ~= self class invalidPort]! !!ICAccountInfo methodsFor: 'validating' stamp: 'tg 7/15/2019 12:08'!hasValidUserInfo	^ self username ~= self class invalidUsername		and: [self password ~= self class invalidPassword]! !!ICAccountInfo methodsFor: 'validating' stamp: 'fr 7/26/2019 15:57'!isValid	^ self hasValidServerInfo and: [self hasValidUserInfo]! !!ICAccountInfo methodsFor: 'converting' stamp: 'tg 7/18/2019 23:07'!asDictionary		| dict |	dict := Dictionary new.	dict at: 'ssl' put: self ssl;		at: 'accountName' put: self accountName;		at: 'address' put: self host;		at: 'port' put: self port;		at: 'username' put: self username;		at: 'password' put: self password.		^ dict	! !!ICAccountInfo methodsFor: 'converting' stamp: 'tg 7/10/2019 17:18'!passwordAsIMAPString		^ '"', self password, '"'! !!ICAccountInfo methodsFor: 'converting' stamp: 'tg 7/10/2019 17:18'!usernameAsIMAPString	^ '"', self username, '"'! !!ICAccountInfo methodsFor: 'action' stamp: 'LW 7/31/2020 11:39'!eraseStoredPassword		self password: ''! !!ICAccountInfo methodsFor: 'printing' stamp: 'fr 7/26/2019 16:52'!printOn: aStream	aStream nextPut: ({		self accountName.		self host.		self port.		self username.		self password.		self ssl	} joinSeparatedBy: ' ')! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICAccountInfo class	instanceVariableNames: ''!!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 17:43'!initialAccountName	^ String empty! !!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 17:43'!initialSsl	^ true! !!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 20:08'!invalidHost	^ String empty! !!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 20:10'!invalidPassword	^ String empty! !!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 20:09'!invalidPort	^ -1! !!ICAccountInfo class methodsFor: 'constants' stamp: 'tg 7/10/2019 20:10'!invalidUsername	^ String empty! !!ICAccountInfo class methodsFor: 'instance creation' stamp: 'NH 7/15/2020 10:14'!newWith: aDataDictionary		^ self new		accountName: (aDataDictionary at: 'accountName' ifAbsent: [nil]);		host: (aDataDictionary at: 'address' ifAbsent: [self invalidHost]);		port: ((aDataDictionary at: 'port' ifAbsent: [self invalidPort]) asNumber);		username: (aDataDictionary at: 'username' ifAbsent: [self invalidUsername]);		password: (aDataDictionary at: 'password' ifAbsent: [self invalidPassword]);		ssl: (aDataDictionary at: 'ssl' ifAbsent: [self initialSsl])! !OrderedCollection subclass: #ICAddressBook	instanceVariableNames: ''	classVariableNames: 'Instance'	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICAddressBook commentStamp: 'LW 8/1/2020 11:23' prior: 0!An ICAddressBook is a collection for the user's contacts containing email addresses of all accounts.This is a singleton which can be accessed with #new.!!ICAddressBook methodsFor: 'action' stamp: 'LW 6/16/2020 09:51'!addEmail: aString	self addIfNotPresent: aString	! !!ICAddressBook methodsFor: 'action' stamp: 'LW 6/16/2020 09:51'!find: anEntry	| index |	index := self indexOf: anEntry.	^ self at: index! !!ICAddressBook methodsFor: 'initialize' stamp: 'LW 6/16/2020 09:51'!feedMeWithEntries: anEmailCollection	anEmailCollection do: [:emailAccount | 		self 			readRootFoldersMailsFrom: emailAccount;			readChildFoldersMailsFrom: emailAccount.]! !!ICAddressBook methodsFor: 'initialize' stamp: 'LW 6/16/2020 09:50'!readChildFoldersMailsFrom: anEmailAccount	anEmailAccount rootFolder recursiveChildFolders do: [:childFolder |			childFolder emails do: [:childFolderEmail | 				self addEmail: childFolderEmail senderAddressFromHeader]]! !!ICAddressBook methodsFor: 'initialize' stamp: 'LW 6/10/2020 13:32'!readRootFoldersMailsFrom: anEmailAccount	anEmailAccount rootFolder emails do: [:rootFolderEmail | 			self addEmail: rootFolderEmail senderAddressFromHeader]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICAddressBook class	instanceVariableNames: ''!!ICAddressBook class methodsFor: 'instance creation' stamp: 'hg 6/24/2020 12:34'!new	Instance ifNil: [Instance := super new: 10].	^ Instance! !Object subclass: #ICEmail	instanceVariableNames: 'body header folder messageID uniqueID'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICEmail commentStamp: 'tg 7/19/2019 10:33' prior: 0!An ICEmail is an object resembling an email residing on a remote server. This is automatically created when calling ICFolder>>fetchHeaders.Instance Variables	body:		The body of the ICEmail. ICEmail>>retrieveBody needs to be called to fill the body.	folder:		The ICFolder this ICEmail resides in.	header:		The header of the ICEmail. This gets parsed into the instance variables date, from, to and subject.	date:		https://tools.ietf.org/html/rfc2822#page-14, date represents the local time and the zone is the timezone information.			!!ICEmail methodsFor: 'comparing' stamp: 'hg 7/30/2020 11:06'!= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ self header = anObject header		and: [ 			self messageID = anObject messageID				and: [ self body = anObject body and: [ self folder = anObject folder and: [ self uniqueID = anObject uniqueID ] ] ] ]! !!ICEmail methodsFor: 'comparing' stamp: 'hg 7/30/2020 11:06'!hash	"Answer an integer value that is related to the identity of the receiver."	^ self header hash		bitXor: (self messageID hash bitXor: (self body hash bitXor: (self folder hash bitXor: self uniqueID hash)))! !!ICEmail methodsFor: 'converting' stamp: 'AR 7/28/2016 14:06'!asString	^ self headerAsString, String cr, String cr, self bodyAsString, String cr! !!ICEmail methodsFor: 'converting' stamp: 'AR 7/28/2016 13:58'!bodyAsString	^ self body asString	! !!ICEmail methodsFor: 'converting' stamp: 'C.G. 7/25/2018 13:47'!headerAsString	| headerFields |		headerFields := self header keys sorted.	^ (headerFields collect: [:headerField |		headerField, ': ', (self header at: headerField)]) joinSeparatedBy: String cr! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/3/2019 21:27'!body	^ body ifNil: [body := String empty]! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:34'!body: aString	body := aString! !!ICEmail methodsFor: 'accessing' stamp: 'tg 7/19/2019 11:31'!dateFormatted	| date formatted |			date := DateAndTime fromSeconds: self dateInSecondsSinceSqueakEpoch + DateAndTime localOffset asSeconds.		formatted := ((date dayOfMonth asString padded: #left to: 2 with: $0) ,'.', 			 (date month asString padded: #left to: 2 with: $0), '.',			 (date year asString padded: #left to: 2 with: $0),' ',			 (date hour24 asString padded: #left to: 2 with: $0),':',			 (date minute asString padded: #left to: 2 with: $0)).				^ formatted! !!ICEmail methodsFor: 'accessing' stamp: 'tg 7/26/2019 21:04'!dateInSecondsSince1980		^ MailMessage new timeFrom: self date! !!ICEmail methodsFor: 'accessing' stamp: 'tg 7/19/2019 10:35'!dateInSecondsSinceSqueakEpoch			^ self dateInSecondsSince1980 + (DateAndTime year: 1980 day: 1) asSeconds! !!ICEmail methodsFor: 'accessing' stamp: 'ms 7/10/2016 13:31'!folder	^ folder! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/14/2019 14:44'!folder: anICFolder	folder := anICFolder! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/3/2019 21:28'!header	^ header ifNil: [header := Dictionary new]! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:37'!header: aDictionary	header := aDictionary! !!ICEmail methodsFor: 'accessing' stamp: 'ms 7/10/2016 13:59'!messageID	^ messageID! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:41'!messageID: aNumber	messageID := aNumber! !!ICEmail methodsFor: 'accessing' stamp: 'hg 7/29/2020 15:25'!serializeToJson	^ Json render: (		JsonObject newFrom: {			'header' -> (JsonObject newFrom: self header).			'body' -> self body.			'messageID' -> self messageID.			'uid' -> self uniqueID})! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/2/2019 15:58'!uniqueID	^ uniqueID ifNil: [uniqueID := 0]! !!ICEmail methodsFor: 'accessing' stamp: 'pm 6/2/2019 15:58'!uniqueID: aString	uniqueID := aString! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!contentTransferEncoding	^ self header at: #contentTransferEncoding ifAbsent: String empty! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!contentTransferEncoding: aContentTransferEncoding	self header at: #contentTransferEncoding put: aContentTransferEncoding! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!contentType	^ self header at: #contentType ifAbsent: String empty! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!contentType: aContentType	self header at: #contentType put: aContentType! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!date	^ self header at: #date ifAbsent: String empty! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:46'!date: aDate	self header at: #date put: aDate! !!ICEmail methodsFor: 'accessing-header' stamp: 'DH 7/19/2018 21:58'!deleted	^ self header at: #deleted ifAbsent: [false]! !!ICEmail methodsFor: 'accessing-header' stamp: 'DH 7/19/2018 19:43'!deleted: aFlag	self header at: #deleted put: aFlag ! !!ICEmail methodsFor: 'accessing-header' stamp: 'LW 8/1/2020 12:06'!deserializeFrom: aJson	self header: (Dictionary newFrom: (aJson at: 'header' ifAbsent: [JsonObject new]));		body: (aJson at: 'body');		messageID: (aJson at: 'messageID');		uniqueID: (aJson at: 'uid')! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:47'!flagged	^ self header at: #flagged ifAbsent: false! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:47'!flagged: aFlag	self header at: #flagged put: aFlag! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:47'!from	^ self header at: #from ifAbsent: String empty! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:47'!from: aSender	self header at: #from put: aSender! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:49'!seen	^ self header at: #seen ifAbsent: true! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:49'!seen: aFlag	self header at: #seen put: aFlag! !!ICEmail methodsFor: 'accessing-header' stamp: 'hg 7/3/2020 16:10'!sender	| fromCollection |	fromCollection := self from findBetweenSubStrs: '<>'.	^ (fromCollection at: 2 ifAbsent: [fromCollection at: 1 ifAbsent: [ '' ]])! !!ICEmail methodsFor: 'accessing-header' stamp: 'LW 8/2/2020 13:58'!senderAddressFromHeader	^ (MailAddressParser addressesIn: self from) first! !!ICEmail methodsFor: 'accessing-header' stamp: 'tg 7/19/2019 11:45'!subject	^ self header at: #subject ifAbsent: String empty! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:49'!subject: aSubject	self header at: #subject put: aSubject! !!ICEmail methodsFor: 'accessing-header' stamp: 'hg 7/30/2020 11:25'!to	^ self header at: #to ifAbsent: Array new! !!ICEmail methodsFor: 'accessing-header' stamp: 'C.G. 7/25/2018 13:49'!to: aReceiver	self header at: #to put: aReceiver! !!ICEmail methodsFor: 'action' stamp: 'lvm 5/20/2018 20:10'!open	ICEmailDialog openWith: self! !!ICEmail methodsFor: 'action' stamp: 'JJ 8/2/2020 15:33'!retrieveBody		"this is the only action that the email has to be responsible for, because it is called when an email is opened"	self folder endpoint retrieveBody: self.	^'Content-Type: ', (self contentType), Character cr,		'Content-Transfer-Encoding: ', self contentTransferEncoding,		Character cr, Character cr, self body! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICEmail class	instanceVariableNames: ''!!ICEmail class methodsFor: 'instance creation' stamp: 'hg 7/30/2020 09:50'!newFromJsonStream: aStream		^ self basicNew		deserializeFrom: (Json readFrom: aStream);		initialize;		yourself! !Object subclass: #ICEndPoint	instanceVariableNames: 'stream accountInfo loggedIn rootFolder lastResponse uids hierarchyDelimiter currentFolderName fatalErrorOccured folderNameOfTrash readWriter'	classVariableNames: 'ConnectionConfigurations'	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICEndPoint commentStamp: 'LW 8/2/2020 14:03' prior: 0!An ICEndPoint is main class for our framework, handling server communication.Instance Variables	stream:					Contains an ICStreamWrapper, resembling the connection to the server.	accountInfo:			Contains the ICAccountInfo, i.e. the username and password of the current connection.	loggedIn:				Returns a boolean value indicating if the user is currently logged in.	rootFolder:				A virtual ICFolder containing all parsed folders from the server as children.	lastResponse:			Contains the complete (possibly multi-line) answer for the last sent command.	uids: 					Collection of unique ids of messages.	hierarchyDelimiter:		Symbol indicating the delimiter for hierachies.	currentFolderName: 	Folder name string of the currently requesting folder.	fatalErrorOccured: 		Boolean indicator whether an error occured or not after a request.      folderNameOfTrash: 	Folder name string of the trash folder on the server.	readWriter: 			Responsible for disk I/O. Instance of ICFileReadWriter.!!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:23'!accountInfo	^ accountInfo ifNil: [accountInfo := ICAccountInfo new]! !!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/10/2019 17:24'!accountInfo: anICAccountInfo	accountInfo := anICAccountInfo! !!ICEndPoint methodsFor: 'accessing' stamp: 'C.G. 7/25/2018 13:50'!currentFolderName	^ currentFolderName! !!ICEndPoint methodsFor: 'accessing' stamp: 'C.G. 7/25/2018 13:50'!currentFolderName: aFolderName	currentFolderName := aFolderName! !!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/26/2019 21:05'!fatalErrorOccured	^ fatalErrorOccured ifNil: [fatalErrorOccured := false]! !!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/26/2019 21:05'!fatalErrorOccured: aBoolean		fatalErrorOccured := aBoolean! !!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/26/2019 14:12'!folderNameOfTrash	^ folderNameOfTrash! !!ICEndPoint methodsFor: 'accessing' stamp: 'tg 7/26/2019 14:13'!folderNameOfTrash: aNameString	folderNameOfTrash := aNameString! !!ICEndPoint methodsFor: 'accessing' stamp: 'mw 5/11/2018 10:37'!hierarchyDelimiter	^ hierarchyDelimiter	! !!ICEndPoint methodsFor: 'accessing' stamp: 'mw 5/11/2018 10:37'!hierarchyDelimiter: aSymbol	hierarchyDelimiter := aSymbol	! !!ICEndPoint methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:09'!host	^ self accountInfo host! !!ICEndPoint methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:10'!lastResponse	^ lastResponse ifNil: [lastResponse := OrderedCollection new]! !!ICEndPoint methodsFor: 'accessing' stamp: 'lvm 5/24/2018 10:16'!lastResponse: anOrderedCollection	lastResponse := anOrderedCollection! !!ICEndPoint methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:07'!loggedIn	^ loggedIn ifNil: [loggedIn := false]! !!ICEndPoint methodsFor: 'accessing' stamp: 'js 5/15/2016 13:09'!loggedIn: aBool	loggedIn := aBool! !!ICEndPoint methodsFor: 'accessing' stamp: 'NH 7/30/2020 21:43'!readWriter	^ readWriter ifNil: [readWriter := ICFileReadWriter newWith: self]! !!ICEndPoint methodsFor: 'accessing' stamp: 'NH 7/30/2020 21:42'!readWriter: anObject	readWriter := anObject! !!ICEndPoint methodsFor: 'accessing' stamp: 'hg 7/29/2020 10:50'!rootDirectoryName		^ (SecureHashAlgorithm new 		hashMessage: self host, self username) 			asString first: self class accountFolderHashRelevantCharacters! !!ICEndPoint methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:09'!rootFolder	^ rootFolder ifNil: [rootFolder := ICFolder newRootFolderWith: self]! !!ICEndPoint methodsFor: 'accessing' stamp: 'js 6/10/2016 15:09'!rootFolder: anICFolder	rootFolder := anICFolder! !!ICEndPoint methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:08'!stream	^ stream ifNil: [stream := ICStreamWrapper new]! !!ICEndPoint methodsFor: 'accessing' stamp: 'js 6/7/2016 10:17'!stream: anICStreamWrapper	stream := anICStreamWrapper! !!ICEndPoint methodsFor: 'accessing' stamp: 'C.G. 7/25/2018 13:59'!uids	^ uids! !!ICEndPoint methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:52'!uids: anOrderedCollection	uids := anOrderedCollection! !!ICEndPoint methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:09'!username	^ self accountInfo username! !!ICEndPoint methodsFor: 'error handling' stamp: 'tg 7/10/2019 19:29'!checkConnected		(self fatalErrorOccured)		ifTrue: [^ false].  	self stream isConnected 		ifFalse: [			self fatalErrorOccured: true.			^ false].  	^ true! !!ICEndPoint methodsFor: 'error handling' stamp: 'pm 7/25/2019 17:59'!checkForBadRequest	(self fatalErrorOccured) 		ifTrue: [^ false].  	(ICParser responseIsError: self stream lastResponse) ifTrue: [		self fatalErrorOccured: true.		^ Error signal: self class errorBadProtocol]. 	^ false! !!ICEndPoint methodsFor: 'error handling' stamp: 'tg 7/26/2019 11:43'!checkForParameterError		(self fatalErrorOccured)		ifTrue: [^ false].  	(ICParser responseIsParameterError: self stream lastResponse) ifTrue: [		self fatalErrorOccured: true.		self inform: 'Wrong username or password'.		^ true].  	^ false! !!ICEndPoint methodsFor: 'login' stamp: 'tg 7/15/2019 12:44'!checkLoggedIn  	(self fatalErrorOccured)		ifTrue: [^ false]. 	self loggedIn ifFalse: [		self fatalErrorOccured: true.		^ false].		^ true ! !!ICEndPoint methodsFor: 'login' stamp: 'LW 8/2/2020 16:30'!connectAndLoginWith: anICAccountInfo	self accountInfo: anICAccountInfo.	[self 		connect;		login]	valueWithin: 5 seconds 	onTimeout: [self handleTimeout]! !!ICEndPoint methodsFor: 'login' stamp: 'JJ 8/2/2020 16:43'!login		(self throwErrorIfNotLoggedIn) ifFalse: [^false].  	(self throwErrorIfAccountInvalid) ifFalse: [^false].		self sendLoginCommand.		(self throwErrorIfNotLoggedIn) ifFalse: [^false].		(ICFileReadWriter newWith: self) readEmailsFromDisk.	^ true! !!ICEndPoint methodsFor: 'login' stamp: 'tg 7/25/2019 12:42'!logout	self checkConnected.	self sendCommand: ICCommand logout.	self		fetchNextResponse;		close.	^ true! !!ICEndPoint methodsFor: 'login' stamp: 'JJ 8/2/2020 16:17'!sendLoginCommand		self sendCommand: (ICCommand loginWith: self accountInfo);		fetchNextResponse;		loggedIn: (ICParser commandSucceeded: self stream lastResponse)! !!ICEndPoint methodsFor: 'login' stamp: 'tg 7/26/2019 22:12'!testAccountWith: anAccountInfo	self connectAndLoginWith: anAccountInfo. 	^ self fatalErrorOccured not! !!ICEndPoint methodsFor: 'login' stamp: 'JJ 8/2/2020 16:42'!throwErrorIfAccountInvalid  		(self accountInfo isValid) ifFalse: [		self fatalErrorOccured: true.		^ false].	^true! !!ICEndPoint methodsFor: 'login' stamp: 'JJ 8/2/2020 16:15'!throwErrorIfNotLoggedIn		(self checkConnected) ifFalse: [		self fatalErrorOccured: true.		self inform: 'Cant connect to the server'. 		^ false].	^ true! !!ICEndPoint methodsFor: 'connection' stamp: 'AR 5/31/2016 11:12'!close	self stream close.	self loggedIn: false! !!ICEndPoint methodsFor: 'connection' stamp: 'tg 7/15/2019 13:27'!connect	self connectWith: self class defaultStreamClass! !!ICEndPoint methodsFor: 'connection' stamp: 'tg 7/18/2019 23:00'!connectWith: aStreamClass	self accountInfo isValid ifFalse: [^ Error signal: self class errorInvalidConnectionConfiguration]. 	[self stream		ssl: self accountInfo ssl;		connectTo: self accountInfo host on: self accountInfo port with: aStreamClass;		nextResponse "skip server greetings"]	on: Error	do: [self fatalErrorOccured: true]! !!ICEndPoint methodsFor: 'connection' stamp: 'LW 8/2/2020 16:26'!handleTimeout			(self fatalErrorOccured)		ifFalse: [			self inform: 'Connection could not be established due to a timeout'.			self fatalErrorOccured: true]! !!ICEndPoint methodsFor: 'connection' stamp: 'js 6/7/2016 10:13'!isConnected	^ self stream isConnected! !!ICEndPoint methodsFor: 'connection' stamp: 'lvm 7/23/2018 23:33'!preventTimeout	[self refreshConnectionProcess] forkAt: Processor userBackgroundPriority! !!ICEndPoint methodsFor: 'connection' stamp: 'ok 7/26/2019 21:04'!refreshConnectionProcess	[self isConnected and: [self loggedIn]]		whileTrue: [			self sendCommand: ICCommand noop.			self fetchNextResponse.			(Delay forSeconds: self class refreshConnectionIntervalInSeconds) wait]! !!ICEndPoint methodsFor: 'connection' stamp: 'DH 6/26/2018 20:21'!sendCommand: aCommand		self stream sendCommand: aCommand! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'fr 7/26/2019 15:48'!currentUIDs	self		sendCommand: ICCommand allUIDs;		fetchNextResponse.			self 		uids: ((self lastResponse first subStrings: ' ') asOrderedCollection 		removeFirst;		removeFirst; 		yourself)! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'ok 7/26/2019 21:01'!currentUIDsFor: anICFolder	| isEmpty |			self select: anICFolder path.	isEmpty := true.		self lastResponse do:		[:line | (line findString: 'EXISTS') positive			ifTrue: [isEmpty := false]].		isEmpty	ifFalse: [		self			sendCommand: ICCommand allUIDs;			fetchNextResponse.		self 			uids: ((self lastResponse first subStrings: ' ') asOrderedCollection 			removeFirst;			removeFirst; 			yourself)]	ifTrue: [^ OrderedCollection new]! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'pm 7/15/2019 20:28'!fetchMailsBeginningAt: aBeginUID number: numberOfMessages 	| start end possibleUID numberToFetch |		"aBeginUID is the last known UID of the folder. numberOfMessages is the number	 of messages which should be fetched starting at this UID"		numberToFetch := numberOfMessages.		self currentUIDs.	possibleUID := self uids select: [:uid | uid asNumber < aBeginUID].	possibleUID size < numberToFetch		ifTrue: [numberToFetch := possibleUID size].			numberToFetch = 0 ifTrue: [^ OrderedCollection new].				possibleUID := possibleUID copyFrom: (possibleUID size - numberToFetch + 1) to: possibleUID size. 			start := possibleUID first.	end := possibleUID last.				^ self maildirDiffFetchHeadersFrom: start asString to: end asString! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'pm 7/15/2019 20:37'!fetchNextResponse		| multiLineResponse |	multiLineResponse := OrderedCollection new.	self stream nextResponse.	self 		checkForBadRequest;		checkForParameterError.		[ICParser commandSucceeded: self stream lastResponse]		whileFalse: [ 			multiLineResponse add: self stream lastResponse.			self stream nextResponse].		self lastResponse: multiLineResponse! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'pm 7/15/2019 20:42'!fillBodyFor: anEmail		self 		sendCommand: (ICCommand fetchBody: anEmail messageID);		fetchNextResponse.	anEmail body: (ICParser parseFetchBody: self lastResponse)! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'js 6/14/2016 12:31'!listAllFolders	^ self listFoldersIn: String empty using: '*'! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'pm 7/23/2019 14:51'!listFoldersIn: root using: filter	self 		checkConnected;		checkLoggedIn.			self sendCommand: (ICCommand listSubfoldersOf: root filterBy: filter).			^ self parseListResponse! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'tg 7/15/2019 13:31'!maildirDiffFetchHeadersFrom: anUID	self uids		ifEmpty: [ ^ OrderedCollection new];		ifNil: [^ OrderedCollection new]		ifNotNil: [^ self maildirDiffFetchHeadersFrom: (anUID + 1) to: (self uids last + 1)]! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'ok 7/26/2019 21:02'!maildirDiffFetchHeadersFrom: start to: end	| searchBegin searchEnd mailFolder |	(FileDirectory default directoryExists: (FileDirectory default fullPathFor: self maildirFileName)) 		ifTrue: [			mailFolder := FileDirectory default on: self maildirFileName.			searchBegin := mailFolder	fileNamesMatching: (end asString).			searchEnd := mailFolder	fileNamesMatching: (start asString).				(searchBegin notEmpty and: [searchEnd notEmpty])				ifTrue: [^ OrderedCollection new]].     ^ self       	sendCommand: (ICCommand fetchHeadersForUIDsFrom: start to: end);		fetchNextResponse;		parseFetchHeaders: self lastResponse! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'LW 8/1/2020 09:55'!retrieveBody: anEmail		self 			select: anEmail folder path;			fillBodyFor: anEmail.! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'pm 7/25/2019 17:45'!retrieveFlagsFrom: anUID to: anotherUID in: aFolder		self 		sendCommand: (ICCommand fetchFlagsForUIDsFrom: anUID to: anotherUID);		fetchNextResponse.			self parseFetchedFlagsAndPopulate: aFolder! !!ICEndPoint methodsFor: 'protocol handling - fetch' stamp: 'fr 7/26/2019 15:45'!select: aFolderName	self	currentFolderName: aFolderName;		sendCommand: (ICCommand select: aFolderName);		fetchNextResponse! !!ICEndPoint methodsFor: 'protocol handling - delete' stamp: 'hg 7/31/2020 12:21'!deleteEmail: anEmail		self select: anEmail folder path.	self sendCommand: (ICCommand deleteEmail: anEmail messageID).	self fetchNextResponse.		self moveEmail: anEmail to: self folderNameOfTrash.! !!ICEndPoint methodsFor: 'protocol handling - delete' stamp: 'hg 7/31/2020 12:24'!deleteMailLocally: anEmail	anEmail folder removeMail: anEmail.	self readWriter delete: anEmail! !!ICEndPoint methodsFor: 'protocol handling - delete' stamp: 'NH 8/2/2020 11:35'!expungeEmails	self sendCommand: ICCommand expungeEmails.		self fetchNextResponse! !!ICEndPoint methodsFor: 'protocol handling' stamp: 'ok 7/26/2019 17:45'!folderFromResponse: responseLine	| folder folderPath parent namePart|			namePart := (responseLine copyAfter: ICCommand protocolQuote asCharacter).		folder := ICParser parseFolderPathFrom: namePart.	self hierarchyDelimiter: folder hierarchyDelimiter.	folderPath := folder pathAsArray.		(responseLine includesSubstring: '\Trash') ifTrue: [self folderNameOfTrash: folderPath first].		parent := self rootFolder childFolderNamed: folderPath first 		ifAbsent: [ICFolder named: folderPath first in: self rootFolder with: self].		folderPath allButFirst do: [ :name | parent := parent childFolderNamed: name 		ifAbsent: [ICFolder named: name in: parent with: self]]! !!ICEndPoint methodsFor: 'protocol handling' stamp: 'NH 7/30/2020 22:13'!parseFetchHeaders: headerLines	| folder parseResult mailCollection |		headerLines ifEmpty: [^ OrderedCollection new].	mailCollection := OrderedCollection new.	parseResult := ICParser parseFetchMailStream: (ReadStream on: (headerLines joinSeparatedBy: Character cr)).			folder := self rootFolder childFolderNamed: (self currentFolderName) with: (self hierarchyDelimiter).	 	"iterate over all pairs of IDs and messages"	parseResult keysAndValuesDo: [:id :message | 		| mail |		"parse the message and ID into a ICMail"		mail := ICParser parseFetchHeader: message withId: id.		mailCollection add: mail.		"store the ICMail in the appropriate folder and write it on the disk"		mail folder: folder.		self readWriter write: mail].		^ mailCollection! !!ICEndPoint methodsFor: 'protocol handling' stamp: 'LW 8/2/2020 16:53'!parseFetchedFlagsAndPopulate: aFolder	| flagsPerUID | 		flagsPerUID := ICParser parseFetchedFlagsAndPopulate: self lastResponse.		aFolder emails do: [:email | 		flagsPerUID at: email uniqueID asString ifPresent: [:flags |			email seen: (flags includes: '\Seen').			email flagged: (flags includes: '\Flagged').			email deleted: (flags includes: '\Deleted').			self readWriter write: email]]! !!ICEndPoint methodsFor: 'protocol handling' stamp: 'tg 7/26/2019 14:20'!parseListResponse		self fetchNextResponse.	self lastResponse do: [:each | self folderFromResponse: each]! !!ICEndPoint methodsFor: 'storage' stamp: 'hg 7/29/2020 10:50'!maildirFileName	^ 'Maildir', 		FileDirectory slash, 		self rootDirectoryName, 		FileDirectory slash, 				self currentFolderName copyReplaceAll: (self hierarchyDelimiter) with: (FileDirectory slash)! !!ICEndPoint methodsFor: 'protocol handling - flags' stamp: 'LW 8/1/2020 09:32'!modifyFlag: aFlag for: anEmail		(anEmail perform: aFlag)		ifTrue: [self resetFlag: anEmail and: aFlag]		ifFalse: [self setFlag: anEmail and: aFlag]! !!ICEndPoint methodsFor: 'protocol handling - flags' stamp: 'JJ 7/31/2020 13:55'!resetDeletedFlagWhenRecovering: anEmail	(anEmail folder folderName = self folderNameOfTrash)		ifTrue: [ self resetFlag: anEmail and: #deleted]! !!ICEndPoint methodsFor: 'protocol handling - flags' stamp: 'tg 7/26/2019 13:44'!resetFlag: anEmail and: aFlag		self sendCommand: (ICCommand resetFlag: aFlag asString for: anEmail messageID).	self fetchNextResponse! !!ICEndPoint methodsFor: 'protocol handling - flags' stamp: 'tg 7/26/2019 13:44'!setFlag: anEmail and: aFlag	self sendCommand: (ICCommand setFlag: aFlag asString for: anEmail messageID).		self fetchNextResponse! !!ICEndPoint methodsFor: 'protocol handling - move' stamp: 'JJ 7/31/2020 13:54'!moveEmail: anEmail to: aFolder	self select: anEmail folder path.	self deleteMailLocally: anEmail.		self resetDeletedFlagWhenRecovering: anEmail.		self sendCommand: (ICCommand moveEmail: anEmail messageID to: aFolder).			self fetchNextResponse.	(self rootFolder childFolderNamed: aFolder with: (self hierarchyDelimiter)) update! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICEndPoint class	instanceVariableNames: ''!!ICEndPoint class methodsFor: 'constants' stamp: 'ok 7/26/2019 19:11'!accountFolderHashRelevantCharacters	^ 10! !!ICEndPoint class methodsFor: 'constants' stamp: 'tg 7/15/2019 13:26'!defaultStreamClass	^ SocketStream! !!ICEndPoint class methodsFor: 'constants' stamp: 'ok 7/26/2019 21:04'!refreshConnectionIntervalInSeconds	^ 60 * 10! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'LW 7/31/2020 11:42'!addConfiguration: anAccountInfo		self basicConnectionConfigurations add: anAccountInfo! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'tg 7/8/2019 15:14'!basicConnectionConfigurations		^ ConnectionConfigurations ifNil: [ConnectionConfigurations := OrderedCollection new]! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'tg 7/8/2019 15:14'!connectionConfigurations	^ self basicConnectionConfigurations copy! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'pm 6/19/2019 14:49'!connectionConfigurations: anOrderedCollection	ConnectionConfigurations := anOrderedCollection! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'LW 7/31/2020 11:29'!eraseStoredPasswords	self basicConnectionConfigurations do: [:anAccountInfo |		anAccountInfo eraseStoredPassword].! !!ICEndPoint class methodsFor: 'configuration storage' stamp: 'NH 7/15/2020 09:55'!removeConfiguration: anAccountInfo	^ self basicConnectionConfigurations remove: anAccountInfo! !!ICEndPoint class methodsFor: 'errors' stamp: 'js 5/15/2016 13:55'!errorBadProtocol	^ 'server protocol not supported'! !!ICEndPoint class methodsFor: 'errors' stamp: 'js 5/15/2016 16:15'!errorInvalidConnectionConfiguration	^ 'the provided connection information is not valid'! !Object subclass: #ICFileReadWriter	instanceVariableNames: 'directoryToFolderDictionary endpoint'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICFileReadWriter commentStamp: 'LW 8/1/2020 11:14' prior: 0!An ICFileReadWriter is a JSON File Writer and Reader handling the file system storage of mails.Instance Variables:	directoryToFolderDictionary: Dictionary that maps a folder instance to each directory.	endpoint: Endpoint instance.!!ICFileReadWriter methodsFor: 'delete file' stamp: 'hg 8/2/2020 19:11'!delete: anICEmail	(FileDirectory default / self endpoint maildirFileName) deleteFileNamed: anICEmail uniqueID ifAbsent: [^ self]! !!ICFileReadWriter methodsFor: 'accessing' stamp: 'hg 7/29/2020 15:35'!directoryToFolderDictionary	^ directoryToFolderDictionary ifNil: [		directoryToFolderDictionary := Dictionary newFrom: {self rootDirectory -> self endpoint rootFolder}]! !!ICFileReadWriter methodsFor: 'accessing' stamp: 'hg 7/29/2020 14:09'!endpoint	^ endpoint! !!ICFileReadWriter methodsFor: 'accessing' stamp: 'hg 7/29/2020 14:09'!endpoint: anObject	endpoint := anObject! !!ICFileReadWriter methodsFor: 'accessing' stamp: 'hg 7/29/2020 13:56'!rootDirectory		^ (FileDirectory default directoryNamed: 'Maildir') directoryNamed: self endpoint rootDirectoryName! !!ICFileReadWriter methodsFor: 'read file' stamp: 'hg 7/29/2020 14:18'!directoryVisitor		^ [:directory | | currentFolder |		(directory = self rootDirectory) ifFalse: [			currentFolder := ICFolder				named: directory pathParts last				in: (self directoryToFolderDictionary at: directory containingDirectory)				with: self endpoint.			directoryToFolderDictionary at: directory put: currentFolder]]! !!ICFileReadWriter methodsFor: 'read file' stamp: 'hg 7/30/2020 09:51'!fileVisitor	 ^ [:file | | currentFolder | 			currentFolder := self directoryToFolderDictionary at: file directory.			currentFolder addMails: {				(ICEmail newFromJsonStream: file) 					folder: currentFolder; 					yourself}.			file close]! !!ICFileReadWriter methodsFor: 'read file' stamp: 'hg 7/29/2020 14:19'!readEmailsFromDisk	self rootDirectory			assureExistence; 			withAllFilesDo: self fileVisitor andDirectoriesDo: self directoryVisitor! !!ICFileReadWriter methodsFor: 'write file' stamp: 'LW 8/2/2020 16:37'!write: anICEmail		(FileDirectory default / self endpoint maildirFileName) assureExistence.			FileStream 		forceNewFileNamed: (self endpoint maildirFileName, FileDirectory slash, anICEmail uniqueID) 		do: [:stream | 			stream nextPutAll: anICEmail 				serializeToJson; 				flush; 				close]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICFileReadWriter class	instanceVariableNames: ''!!ICFileReadWriter class methodsFor: 'instance creation' stamp: 'hg 7/29/2020 13:55'!newWith: anEndpoint	^self new		endpoint: anEndpoint;		yourself! !Object subclass: #ICFolder	instanceVariableNames: 'parent childFolders folderName emails endpoint'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICFolder commentStamp: 'jwe 7/28/2016 14:20' prior: 0!An ICFolder is an object resembling an IMAP folder on a remote server.Instance Variables	childFolders:		All child folders of this folder. This is automatically filled in by the ICEndPoint.	emails:		This contains all ICEmails of this folder after calling ICFolder>>fetchHeaders.	endpoint:		Back reference to the ICEndPoint who created this ICFolder.	name:		The name of the folder.	parent:		The parent ICFolder. This is automatically filled in by the ICEndPoint.			!!ICFolder methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:06'!accountName	^ self endpoint accountInfo accountName! !!ICFolder methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:12'!childFolders	^ childFolders ifNil: [childFolders := OrderedCollection new]! !!ICFolder methodsFor: 'accessing' stamp: 'LW 7/31/2020 12:27'!emails	^ emails ifNil: [emails := OrderedCollection new]! !!ICFolder methodsFor: 'accessing' stamp: 'LW 7/31/2020 12:26'!emails: anOrderedCollection	emails := anOrderedCollection! !!ICFolder methodsFor: 'accessing' stamp: 'ms 7/10/2016 13:24'!endpoint	^ endpoint! !!ICFolder methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:56'!endpoint: anICEndpoint	endpoint := anICEndpoint! !!ICFolder methodsFor: 'accessing' stamp: 'tg 7/19/2019 09:17'!folderName	^ folderName ifNil: [folderName := self class defaultName]! !!ICFolder methodsFor: 'accessing' stamp: 'tg 7/19/2019 09:17'!folderName: aString	folderName := aString! !!ICFolder methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:02'!hierarchyDelimiter	^ self endpoint hierarchyDelimiter! !!ICFolder methodsFor: 'accessing' stamp: 'pm 6/3/2019 18:34'!highestUniqueID		(self emails) ifEmpty: [^ nil].			^ (self emails detectMax: [:mail | mail uniqueID asNumber]) uniqueID! !!ICFolder methodsFor: 'accessing' stamp: 'JJ 6/10/2020 10:47'!isTrashFolder	^ self endpoint folderNameOfTrash = self folderName	! !!ICFolder methodsFor: 'accessing' stamp: 'pm 6/3/2019 18:34'!lowestUniqueID		(self emails) ifEmpty: [^ nil].			^ (self emails detectMin: [:mail | mail uniqueID asNumber]) uniqueID! !!ICFolder methodsFor: 'accessing' stamp: 'LW 8/2/2020 14:27'!numberOfUnseenMails	| numberOfUnseen |		numberOfUnseen := self childFolders detectSum: [:anICFolder | anICFolder numberOfUnseenMails].	^ (numberOfUnseen + (self emails count: [:anICEmail | anICEmail seen not]))! !!ICFolder methodsFor: 'accessing' stamp: 'tg 6/25/2019 21:21'!parent	^ parent! !!ICFolder methodsFor: 'accessing' stamp: 'js 6/7/2016 11:32'!parent: anICFolder	parent := anICFolder! !!ICFolder methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:08'!parentPath	^ self parent path! !!ICFolder methodsFor: 'accessing' stamp: 'tg 7/25/2019 12:56'!recursiveChildFolders		^ {self childFolders collect: [:child | child recursiveChildFolders]. self childFolders} flatten asOrderedCollection! !!ICFolder methodsFor: 'accessing' stamp: 'ok 7/26/2019 19:05'!rootFolder	^ self endpoint rootFolder! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'js 6/7/2016 13:09'!addFolder: child	child parent: self.	self childFolders add: child! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'tg 7/19/2019 09:19'!childFolderNamed: childFolderName ifAbsent: block	^ self childFolders 		detect: [:child | child folderName = childFolderName] 		ifNone: [block value]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'C.G. 6/26/2018 11:01'!childFolderNamed: name with: delimiter	^ self 			childFolderNamed: name 			with: delimiter 			ifAbsent: [Error signal: self class errorChildDoesNotExist]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'tg 7/26/2019 21:52'!childFolderNamed: childFolderName with: delimiter ifAbsent: block	| rootPart childPart child parts |		^ self childFolders 		detect: [:subFolder | subFolder folderName = childFolderName] 		ifNone: [ 			"splice at delimiter and ask child"			parts := childFolderName subStrings: delimiter.			(parts size > 1)				ifTrue: [					rootPart := parts first.					childPart := parts allButFirst joinSeparatedBy: delimiter.					child := self childFolders detect: [ :childFolder | childFolder folderName = rootPart].					child ifNotNil: [^ child childFolderNamed: childPart with: delimiter ifAbsent: block]].			^ block value]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'C.G. 7/25/2018 14:02'!countFolders	^ self childFolders inject: self childFolders size into: [:count :child | count + child countFolders]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'ok 7/26/2019 19:08'!path	^ (self parent == self rootFolder) 		ifTrue: [ self folderName ] 		ifFalse: [ self parentPath, self hierarchyDelimiter, self folderName]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'C.G. 7/25/2018 14:03'!removeFolder: child	^ self removeFolder: child ifAbsent: [Error signal: self class errorChildDoesNotExist]! !!ICFolder methodsFor: 'action - folder hierarchy' stamp: 'C.G. 7/25/2018 14:04'!removeFolder: child ifAbsent: block	(self childFolders includes: child) ifFalse: [^ block value].		child parent: child.	self childFolders remove: child! !!ICFolder methodsFor: 'action - add emails' stamp: 'LW 8/1/2020 10:14'!addMails: aMailCollection	"Since Exchange uses other objects than emails we need to exclude them from the list"	self emails addAll: (self sanitizeMailCollection: aMailCollection).! !!ICFolder methodsFor: 'action - freshness' stamp: 'JJ 8/2/2020 15:52'!ensureFreshness		" This method is part of a good first issue with no. 366 :)"	| relevantUIDs localMails min max |		self emails ifEmpty: [^ self].		" we cant access first and last of the sortedCollection because its sorted by date, not by UID "	min := self lowestUniqueID.	max := self highestUniqueID.			self endpoint currentUIDs.		relevantUIDs := self endpoint uids select: [ :uid | (uid asNumber <= max) and: [uid asNumber >=min]].	"search for uids, which are in storage, but not on the server --> they were moved"	localMails := self emails copy.	relevantUIDs do: [ :uid | localMails removeAllSuchThat: [ :mail | mail uniqueID = uid]].		"everything left in localMails has changed, and therefore can be removed"	localMails do: [ :mail | self endpoint deleteMailLocally: mail]! !!ICFolder methodsFor: 'action - remove emails' stamp: 'NH 8/2/2020 11:36'!expungeEmails		self emails do: [ :email |		email deleted ifTrue: [self endpoint deleteMailLocally: email]].	self endpoint		select: self path;		expungeEmails! !!ICFolder methodsFor: 'action - remove emails' stamp: 'tg 7/26/2019 21:59'!removeMail: anICEmail	self emails remove: anICEmail.! !!ICFolder methodsFor: 'action - update emails' stamp: 'JJ 8/2/2020 15:52'!fetchHeadersFrom: anUID		self emails addAll: (self endpoint		currentUIDsFor: self;		maildirDiffFetchHeadersFrom: anUID).			self ensureFreshness.	self emails ifEmpty: [^ self].	self retrieveFlagsFrom: self emails last uniqueID to: self emails first uniqueID! !!ICFolder methodsFor: 'action - update emails' stamp: 'LW 8/2/2020 14:35'!fetchNumberOfLatestEmails: aNumber	| startUID allUIDs |		self endpoint currentUIDsFor: self.	allUIDs := self endpoint uids.	allUIDs ifEmpty: [^ OrderedCollection new].	(allUIDs size - aNumber) strictlyPositive		ifTrue: [startUID := allUIDs at: (allUIDs size - aNumber)]		ifFalse: [startUID := (allUIDs first) - 1].	self fetchHeadersFrom: startUID! !!ICFolder methodsFor: 'action - update emails' stamp: 'tg 7/26/2019 21:05'!loadOlderMails	self emails addAll: 		(self endpoint			currentUIDsFor: self;			fetchMailsBeginningAt: self lowestUniqueID number: self class numberOfHeadersToFetchAtLoadOlderMails)! !!ICFolder methodsFor: 'action - update emails' stamp: 'JJ 8/2/2020 15:36'!modifyFlag: aFlag for: anEmail	self retrieveFlagsFor: anEmail.	self endpoint modifyFlag: aFlag for: anEmail! !!ICFolder methodsFor: 'action - update emails' stamp: 'JJ 8/2/2020 15:25'!retrieveFlagsFor: anEmail		self retrieveFlagsFrom: anEmail uniqueID to: anEmail uniqueID! !!ICFolder methodsFor: 'action - update emails' stamp: 'JJ 8/2/2020 15:33'!retrieveFlagsFrom: anUID to: anotherUID	self endpoint 		select: self path;		retrieveFlagsFrom: anUID to: anotherUID in: self! !!ICFolder methodsFor: 'action - update emails' stamp: 'LW 8/2/2020 14:34'!startUpdateProcess: anUID	(self folderName = 'root') ifTrue: [^self].		[anUID		ifNil: [self fetchNumberOfLatestEmails: self class numberOfHeadersToFetchAtTheBeginning]		ifNotNil: [self fetchHeadersFrom: anUID]]	on: Error	do: [:e | self inform: e asString]! !!ICFolder methodsFor: 'action - update emails' stamp: 'pm 6/3/2019 18:34'!update	self startUpdateProcess: self highestUniqueID.		self childFolders do: [:anICFolder | anICFolder update]! !!ICFolder methodsFor: 'action - update emails' stamp: 'LW 6/3/2020 15:13'!updateAndShowProgressWith: aBlock		ProgressNotification 		signal: (aBlock value) 		extra: (self accountName, ' Mailbox. Folder: ', self folderName).		self startUpdateProcess: self highestUniqueID.	self childFolders do: [:anICFolder | anICFolder updateAndShowProgressWith: aBlock]! !!ICFolder methodsFor: 'action - sanitize emails' stamp: 'LW 5/20/2020 09:49'!sanitizeMailCollection: aMailCollection		^ aMailCollection select: [:mail | mail date notEmpty]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICFolder class	instanceVariableNames: ''!!ICFolder class methodsFor: 'constants' stamp: 'js 6/7/2016 11:49'!defaultName	^ 'root'! !!ICFolder class methodsFor: 'constants' stamp: 'DH 7/22/2018 22:37'!numberOfHeadersToFetchAtLoadOlderMails	^ 10! !!ICFolder class methodsFor: 'constants' stamp: 'DH 7/22/2018 22:37'!numberOfHeadersToFetchAtTheBeginning	^ 100! !!ICFolder class methodsFor: 'errors' stamp: 'js 6/14/2016 09:27'!errorChildDoesNotExist	^ 'Child does not exist'! !!ICFolder class methodsFor: 'instance creation' stamp: 'tg 7/19/2019 09:19'!named: name in: parent with: endpoint	| newFolder |		newFolder := (self new)		folderName: name;		endpoint: endpoint.			parent addFolder: newFolder.		^ newFolder! !!ICFolder class methodsFor: 'instance creation' stamp: 'C.G. 7/25/2018 14:12'!newRootFolderWith: endpoint		| newFolder |		newFolder := self new.	newFolder endpoint: endpoint.			^ newFolder! !SocketStream subclass: #ICNullStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICNullStream commentStamp: 'tg 7/25/2019 12:25' prior: 0!An ICNullStream is a Null Object resembling an SocketStream. !!ICNullStream methodsFor: 'connection' stamp: 'js 6/7/2016 10:02'!close	^ true! !!ICNullStream methodsFor: 'connection' stamp: 'js 6/7/2016 10:04'!isConnected	^ false! !!ICNullStream methodsFor: 'connection' stamp: 'js 6/7/2016 10:02'!nextLine	^ String empty! !!ICNullStream methodsFor: 'connection' stamp: 'js 6/7/2016 10:07'!sendCommand: aString	^ false! !Object subclass: #ICStreamWrapper	instanceVariableNames: 'host port stream lastResponse ssl'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Core'!!ICStreamWrapper commentStamp: 'ms 7/28/2016 11:51' prior: 0!An ICStreamWrapper capsules low-level stream interactions.Instance Variables	host:		Contains the host name.	lastResponse:		Contains the (possibly multi-line) response to our last sent command.	port:		Contains the port.	ssl:		A boolean flag indicating whether SSL is enabled.	stream:		Contains the SocketStream (if SSL is disabled) or SecureSocketStream (if SSL is enabled) of our connection.!!ICStreamWrapper methodsFor: 'connection' stamp: 'js 6/14/2016 10:43'!close		self stream close! !!ICStreamWrapper methodsFor: 'connection' stamp: 'LW 8/1/2020 10:24'!connectTo: aHost on: aPort	| hostAddress |		self ssl ifTrue: [^ self sslConnectTo: aHost on: aPort].		hostAddress := NetNameResolver addressForName: aHost.	self close.	self stream: (SocketStream openConnectionToHost: hostAddress port: aPort)! !!ICStreamWrapper methodsFor: 'connection' stamp: 'LW 8/1/2020 10:24'!connectTo: aHost on: aPort with: aStreamClass	| hostAddress |		self ssl ifTrue: [^ self sslConnectTo: aHost on: aPort].			hostAddress := NetNameResolver addressForName: aHost.	self close.		self stream: (aStreamClass openConnectionToHost: hostAddress port: aPort)! !!ICStreamWrapper methodsFor: 'connection' stamp: 'tg 7/26/2019 21:57'!sendCommand: aString	self stream sendCommand: aString! !!ICStreamWrapper methodsFor: 'connection' stamp: 'tg 7/26/2019 22:13'!sslConnectTo: aHost on: aPort	| hostAddress |		hostAddress := NetNameResolver addressForName: aHost.	self stream: (SecureSocketStream openConnectionToHost: hostAddress port: aPort timeout: self class connectionTimeout).	self stream sslConnectTo: aHost! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 09:58'!host	^ host! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 09:59'!host: aString	host := aString! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 10:04'!isConnected	^ self stream isConnected! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 10:08'!lastResponse	^ lastResponse! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'ok 7/26/2019 21:15'!lastResponse: anOrderedCollection	lastResponse := anOrderedCollection! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'C.G. 7/25/2018 14:09'!nextResponse	self lastResponse: self stream nextLine.		^ self lastResponse! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 09:59'!port	^ port! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'pm 6/9/2019 16:59'!port: aNumber	port := aNumber! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:14'!ssl	^ ssl ifNil: [ssl := false]! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'ms 7/12/2016 09:45'!ssl: aBool	ssl := aBool! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'pm 6/9/2019 13:14'!stream	^ stream ifNil: [stream := ICNullStream new]! !!ICStreamWrapper methodsFor: 'accessing' stamp: 'js 6/7/2016 10:05'!stream: aStream	stream := aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICStreamWrapper class	instanceVariableNames: ''!!ICStreamWrapper class methodsFor: 'constants' stamp: 'ok 7/26/2019 18:50'!connectionTimeout	^ 10! !