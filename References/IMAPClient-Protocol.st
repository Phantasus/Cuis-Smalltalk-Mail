Object subclass: #ICCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Protocol'!!ICCommand commentStamp: 'pm 7/23/2019 15:11' prior: 0!ICCommands builds commands to send to the server.The commands are conform to the IMAProtocol.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICCommand class	instanceVariableNames: ''!!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:18'!allUIDs	^ self join: {'UID SEARCH ALL'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:46'!deleteEmail: aMessageId	^ self join: {'STORE' . aMessageId . '+FLAGS \Deleted'}! !!ICCommand class methodsFor: 'commands' stamp: 'NH 8/2/2020 11:35'!expungeEmails	^ self join: {'EXPUNGE'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:48'!fetchBody: aMessageId	^ self join: {'FETCH' . aMessageId . 'body[TEXT]'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/24/2019 21:18'!fetchFlagsForUIDsFrom: aBeginUID to: anEndUID	^ self join: {'UID FETCH' . (aBeginUID asString, ':', anEndUID asString) . '(FLAGS)'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/24/2019 21:18'!fetchHeadersForUIDsFrom: aBeginId to: anEndId	^ self join: {		'UID FETCH' .		(aBeginId asString, ':', anEndId asString) .		'(FLAGS BODY.PEEK[HEADER.FIELDS (from to subject date content-type content-transfer-encoding)])'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:50'!listSubfoldersOf: aFolder filterBy: aFilter	^ self join: {'LIST' . self putInQuotes: aFolder . self putInQuotes: aFilter}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:52'!loginWith: anAccountInfo	^ self join: {'LOGIN' . anAccountInfo usernameAsIMAPString . anAccountInfo passwordAsIMAPString}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:53'!logout	^ self join: {'LOGOUT'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 14:54'!moveEmail: aMessageId to: aFolder	^ self join: {'MOVE' . aMessageId . self putInQuotes: aFolder}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 15:09'!noop	^ self join: {'NOOP'}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 18:29'!resetFlag: aFlagString for: aMessageId	(self isValidFlag: aFlagString) ifFalse: [self error: 'Trying to send invalid Flag'].	^ self join: {'STORE' . aMessageId . '-FLAGS \', aFlagString withFirstCharacterUppercase}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 18:24'!select: aFolder	^ self join: {'SELECT' . self putInQuotes: aFolder}! !!ICCommand class methodsFor: 'commands' stamp: 'pm 7/23/2019 18:29'!setFlag: aFlagString for: aMessageId	(self isValidFlag: aFlagString) ifFalse: [self error: 'Trying to send invalid Flag'].	^ self join: {'STORE' . aMessageId . '+FLAGS \', aFlagString withFirstCharacterUppercase}! !!ICCommand class methodsFor: 'validation' stamp: 'JJ 7/31/2020 13:55'!isValidFlag: aFlagString	^ {'Seen' . 'Flagged' . 'Deleted'} includes: aFlagString withFirstCharacterUppercase! !!ICCommand class methodsFor: 'command building' stamp: 'pm 7/24/2019 21:24'!join: aCommandArray	^ aCommandArray asOrderedCollection			addFirst: self protocolCommandStart;			joinSeparatedBy: self protocolBlank! !!ICCommand class methodsFor: 'command building' stamp: 'pm 7/25/2019 17:25'!putInQuotes: aString	^ ICCommand protocolQuote, aString, ICCommand protocolQuote! !!ICCommand class methodsFor: 'constants' stamp: 'pm 7/24/2019 21:21'!protocolBlank	^ ' '! !!ICCommand class methodsFor: 'constants' stamp: 'pm 7/24/2019 21:21'!protocolCommandStart	^ '.'! !!ICCommand class methodsFor: 'constants' stamp: 'pm 7/24/2019 21:21'!protocolQuote	^ '"'! !Object subclass: #ICParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Protocol'!!ICParser commentStamp: 'pm 7/12/2019 20:20' prior: 0!An ICParser is a stateless method bin that can parse a header, email body and folder path from a response.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICParser class	instanceVariableNames: ''!!ICParser class methodsFor: 'parsing' stamp: 'LW 5/6/2020 16:34'!buildFlagsAssociationFor: aUidString from: aLineString	^ Association key: aUidString first value: (self flags select: [:flag |			aLineString includesSubstring: flag])! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 16:25'!chop: aHeaderString forEmail: anEmail	| headerChunks |	headerChunks := OrderedCollection new.	(aHeaderString subStrings: Character cr asString) do: [:line |		self parse: line forHeaderChunks: headerChunks forEmail: anEmail].	^ headerChunks! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:09'!closeEmailContentFrom: aStream for: anEmailString	anEmailString nextPutAll: (aStream nextDelimited: $)).	aStream next! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/15/2019 20:40'!commandSucceeded: aResponseString	^ aResponseString beginsWith: self commandSucceeded! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 15:44'!continueHeaderChunks: aCollection withLine: aString	(self startsNewHeaderChunk: aString)		ifTrue: [aCollection add: {aString} asOrderedCollection]		ifFalse: [			aCollection ifNotEmpty: [				aCollection last add: aString]]! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:07'!continueMailStream: aStream into: anEmailStringCollection	| id |	id := self readMessageIdFromStream: aStream. 	anEmailStringCollection at: id put: (String streamContents: [:email |		self extractEmailContentFrom: aStream for: email])! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:25'!extractEmailContentFrom: aStream for: anEmailString	| octetSize |	octetSize := self readOctetSizeFrom: aStream for: anEmailString.	self readEmailContentFrom: aStream for: anEmailString bySize: octetSize.	self closeEmailContentFrom: aStream for: anEmailString! !!ICParser class methodsFor: 'parsing' stamp: 'LW 5/6/2020 11:16'!parse: aString forHeaderChunks: aHeaderChunksCollection forEmail: anEmail	(aString includesSubstring: 'UID')			ifTrue: [anEmail uniqueID: ((aString subStrings: ' ') second)]		ifFalse: [self continueHeaderChunks: aHeaderChunksCollection withLine: aString]! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 18:12'!parseFetchBody: aResponseStringArray	^ ((aResponseStringArray 		copyFrom: self fetchBodyOffset		to: (aResponseStringArray size - 1))			joinSeparatedBy: Character cr)! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 18:01'!parseFetchHeader: aHeaderString withId: aMessageID	| email |	email := ICEmail new messageID: aMessageID.	self populate: email withHeaderChunks: (self chop: aHeaderString forEmail: email).	^ email! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 16:57'!parseFetchMailStream: aStream	| emails |	emails := Dictionary new.	[aStream atEnd] whileFalse: [self continueMailStream: aStream into: emails].	 ^ emails! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:39'!parseFetchedFlagsAndPopulate: aResponseStringArray		| uidPart uid |	 	^ (aResponseStringArray collect: [:line |		uidPart := (line allRegexMatches: 'UID \d*') ifEmpty: [ ^ Dictionary new].		uid := (uidPart first allRegexMatches: '[\d]+') ifEmpty: [ ^ Dictionary new].		self buildFlagsAssociationFor: uid from: line]) as: Dictionary! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 18:06'!parseFolderPathFrom: aResponseString	| splittedResponse |	splittedResponse := self splitFolderPathResponse: aResponseString.	^ ICProtocolFolder		newWithPath: (splittedResponse allButFirst joinSeparatedBy: ' ')		delimitedBy: splittedResponse first! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:58'!parseHeaderContentFrom: aHeaderChunk	^ ((aHeaderChunk joinSeparatedBy: ' ')		copyReplaceFrom: 1 		to: (aHeaderChunk first indexOf: $:) 		with: String empty) withoutLeadingBlanks! !!ICParser class methodsFor: 'parsing' stamp: 'LW 5/6/2020 16:34'!parseHeaderFieldFrom: aHeaderChunk	| headerField |		headerField := (aHeaderChunk first subStrings: ' ') first.	(headerField includesSubstring: ':') ifTrue: [headerField := headerField allButLast].	^ headerField! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:36'!populate: anEmail withContentTransferEncoding: aHeaderChunk		anEmail contentTransferEncoding: aHeaderChunk! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:37'!populate: anEmail withContentType: aHeaderChunk		anEmail contentType: aHeaderChunk! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:37'!populate: anEmail withDate: aHeaderChunk		anEmail date: aHeaderChunk! !!ICParser class methodsFor: 'parsing' stamp: 'LW 5/6/2020 16:34'!populate: anEmail withFlags: aHeaderChunk	anEmail seen: (aHeaderChunk includesSubstring: '\Seen').	anEmail flagged: (aHeaderChunk includesSubString: '\Flagged').	anEmail deleted: (aHeaderChunk includesSubString: '\Deleted')! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 16:24'!populate: anEmail withHeaderChunks: aHeaderChunkCollection	aHeaderChunkCollection do: [:chunk |		self populate: anEmail withHeadersFrom: chunk]! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:58'!populate: anEmail withHeadersFrom: aHeaderChunk	| headerField headerContent method |		headerField := self parseHeaderFieldFrom: aHeaderChunk.	headerContent := self parseHeaderContentFrom: aHeaderChunk.	method := 	(self parseMethods at: headerField ifAbsent: nil).	method ifNil: [Transcript show: 'WARNING: No method for parsing Header field:', headerField; cr]		ifNotNil: [method value: headerContent value: anEmail]! !!ICParser class methodsFor: 'parsing' stamp: 'hg 7/30/2020 11:31'!populate: anEmail withReceiver: aHeaderChunk	anEmail to: (aHeaderChunk subStrings: ',') asArray! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:38'!populate: anEmail withSender: aHeaderChunk	anEmail from: aHeaderChunk! !!ICParser class methodsFor: 'parsing' stamp: 'tg 7/26/2019 21:01'!populate: anEmail withSubject: aHeaderChunk	[anEmail subject: aHeaderChunk decodeMimeHeader]		on: Error		do: [self inform: ('A mail in your account has a undecodeable MIME header')]! !!ICParser class methodsFor: 'parsing' stamp: 'tg 7/26/2019 21:04'!readEmailContentCharacterFrom: aStream for: anEmailString	| char |	char := (aStream next) asCharacter.	anEmailString nextPut: char.	(char = Character cr) ifTrue: [^2].	^ 1! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:21'!readEmailContentFrom: aStream for: anEmailString bySize: anOctetSize	| charsLeft |		charsLeft := anOctetSize.	[charsLeft > 0] whileTrue: [		charsLeft := charsLeft - (self readEmailContentCharacterFrom: aStream for: anEmailString)].! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:07'!readMessageIdFromStream: aStream	| id |	aStream next: self lengthOfEmailPrefix.	id := aStream nextDelimited: Character space.	aStream next: self lengthOfFetchPrefix.		^ id! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 17:24'!readOctetSizeFrom: aStream for: anEmailString	anEmailString nextPutAll: (aStream nextDelimited: ${).	^ (aStream nextDelimited: $}) asNumber! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:51'!responseIsError: aResponseString	^ aResponseString beginsWith: self protocolError! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/25/2019 17:53'!responseIsParameterError: aResponseString	^ self protocolParameterError = 		((aResponseString subStrings: ICCommand protocolBlank) 			at: self parameterErrorPosition)! !!ICParser class methodsFor: 'parsing' stamp: 'ok 7/26/2019 18:04'!splitFolderPathResponse: aResponseString	^ (aResponseString copyReplaceAll: ICCommand protocolQuote with: String empty)		subStrings: ICCommand protocolBlank! !!ICParser class methodsFor: 'parsing' stamp: 'pm 7/12/2019 20:07'!startsNewHeaderChunk: aLine	^ (aLine subStrings: ' ') first endsWith: ':'! !!ICParser class methodsFor: 'responses' stamp: 'pm 7/25/2019 17:26'!commandSucceeded	^ {ICCommand protocolCommandStart . 'OK'} joinSeparatedBy: ICCommand protocolBlank! !!ICParser class methodsFor: 'responses' stamp: 'pm 7/25/2019 17:26'!protocolError	^ {ICCommand protocolCommandStart . 'BAD'} joinSeparatedBy: ICCommand protocolBlank! !!ICParser class methodsFor: 'responses' stamp: 'pm 7/12/2019 17:22'!protocolParameterError	^ 'NO'! !!ICParser class methodsFor: 'constants' stamp: 'ok 7/26/2019 18:10'!fetchBodyOffset	^ 2! !!ICParser class methodsFor: 'constants' stamp: 'pm 7/12/2019 18:35'!flags	^ {'\Seen'. '\Deleted'. '\Flagged'}! !!ICParser class methodsFor: 'constants' stamp: 'ok 7/26/2019 16:31'!lengthOfEmailPrefix		^ '* ' size! !!ICParser class methodsFor: 'constants' stamp: 'mt 7/26/2019 15:44'!lengthOfFetchPrefix		^ 'FETCH (' size! !!ICParser class methodsFor: 'constants' stamp: 'pm 7/23/2019 13:31'!parameterErrorPosition	^ 2! !!ICParser class methodsFor: 'constants' stamp: 'pm 7/25/2019 17:40'!parseMethods	^ Dictionary newFrom: {		'To' -> [:headerChunk :email | self populate: email withReceiver: headerChunk].		'From' -> [:headerChunk :email | self populate: email withSender: headerChunk].		'Subject' -> [:headerChunk :email | self populate: email withSubject: headerChunk].		'Date' -> [:headerChunk :email | self populate: email withDate: headerChunk].		'FLAGS' -> [:headerChunk :email | self populate: email withFlags: headerChunk].		'Content-Type' -> [:headerChunk :email | self populate: email withContentType: headerChunk].		'Content-Transfer-Encoding' -> [:headerChunk :email | 			self populate: email withContentTransferEncoding: headerChunk]}! !Object subclass: #ICProtocolFolder	instanceVariableNames: 'hierarchyDelimiter folderPath'	classVariableNames: ''	poolDictionaries: ''	category: 'IMAPClient-Protocol'!!ICProtocolFolder commentStamp: 'pm 7/12/2019 18:04' prior: 0!An ICProtocolFolder is a wrapper for a folder and contains a folder path and a hierarchy delimiterInstance Variables	folderPath:					String	hierarchyDelimiter:		String!!ICProtocolFolder methodsFor: 'accessing' stamp: 'pm 7/12/2019 18:04'!folderPath	^ folderPath! !!ICProtocolFolder methodsFor: 'accessing' stamp: 'pm 7/12/2019 18:05'!folderPath: aFolderPathString	folderPath := aFolderPathString! !!ICProtocolFolder methodsFor: 'accessing' stamp: 'pm 7/12/2019 18:00'!hierarchyDelimiter	^ hierarchyDelimiter! !!ICProtocolFolder methodsFor: 'accessing' stamp: 'pm 7/12/2019 18:00'!hierarchyDelimiter: aHierarchyDelimiterString	hierarchyDelimiter := aHierarchyDelimiterString! !!ICProtocolFolder methodsFor: 'accessing' stamp: 'pm 7/12/2019 18:07'!pathAsArray	^ self folderPath subStrings: self hierarchyDelimiter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ICProtocolFolder class	instanceVariableNames: ''!!ICProtocolFolder class methodsFor: 'instance creation' stamp: 'pm 7/12/2019 18:06'!newWithPath: aFolderPathString delimitedBy: aHierarchyDelimiterString	^ self new		folderPath: aFolderPathString;		hierarchyDelimiter: aHierarchyDelimiterString! !